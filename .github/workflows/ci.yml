name: CI/CD Pipeline

on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main

jobs:
  test:
    name: ğŸ§ª Run Tests
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'

    steps:
      - name: ğŸ“¥ Checkout repo
        uses: actions/checkout@v4

      - name: ğŸŸ¢ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "18"
          cache: "npm"

      - name: ğŸ“¦ Install dependencies
        run: npm ci

      - name: ğŸ¨ Run linting
        run: npm run lint

      - name: ğŸ§ª Run tests
        run: npm test

      - name: ğŸ—ï¸ Build application
        run: npm run build

  build-and-push-image:
    name: ğŸ“¦ Build and Push to ECR
    runs-on: ubuntu-latest
    outputs:
      terraform_bucket: ${{ steps.set-outputs.outputs.terraform_bucket }}
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'

    steps:
      - name: ğŸ“¥ Checkout repo
        uses: actions/checkout@v4

      - name: ğŸ”‘ Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }}
          aws-region: us-east-1

      - name: âœ… Verify AWS Identity
        run: aws sts get-caller-identity

      - name: Create S3 Bucket for Terraform State
        id: bootstrap
        run: |
          BUCKET_PREFIX="terraform-state"
          ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          echo "AWS Account ID: $ACCOUNT_ID"

          REGION="us-east-1"
          BUCKET_NAME="${BUCKET_PREFIX}-${ACCOUNT_ID}"
          echo "S3 bucket name: $BUCKET_NAME"

          # Check if bucket exists, create if not
          echo "Checking S3 bucket..."
          if aws s3api head-bucket --bucket "$BUCKET_NAME" 2>/dev/null; then
            echo "S3 bucket '$BUCKET_NAME' already exists"
          else
            echo "Creating S3 bucket '$BUCKET_NAME'..."
            aws s3api create-bucket --bucket "$BUCKET_NAME" --region "$REGION"
            echo "S3 bucket '$BUCKET_NAME' created successfully"
          fi

          echo "Bootstrap finished. Bucket: $BUCKET_NAME"
          echo "BUCKET_NAME=$BUCKET_NAME" >> $GITHUB_ENV

      - name: ğŸ“ Fetch DB Parameters from SSM
        id: ssm-params
        run: |
          PARAMS=$(aws ssm get-parameters --names "/main/rds_endpoint" "/main/db_username" "/main/db_password" --with-decryption --query "Parameters[].{Name:Name,Value:Value}" --output json)

          echo "DB_PG_HOST=$(echo $PARAMS | jq -r '.[] | select(.Name=="/main/rds_endpoint") | .Value')" >> $GITHUB_ENV
          echo "DB_PG_USER=$(echo $PARAMS | jq -r '.[] | select(.Name=="/main/db_username") | .Value')" >> $GITHUB_ENV
          DB_PASS=$(echo $PARAMS | jq -r '.[] | select(.Name=="/main/db_password") | .Value')
          echo "DB_PG_PASSWORD=$DB_PASS" >> $GITHUB_ENV

          echo "::add-mask::$DB_PASS"

      - name: ğŸ“¦ Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: ğŸ·ï¸ Define Image Tags
        id: tags
        run: |
          COMMIT_HASH=${{ github.sha }}
          ECR_URL=${{ secrets.ECR_REPOSITORY_URL }} # Usa a URL do repositÃ³rio a partir dos segredos

          TAGS="${ECR_URL}:${COMMIT_HASH}"

          if [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            TAGS="$TAGS,${ECR_URL}:latest,${ECR_URL}:main"
          fi

          echo "image_tags=$(echo $TAGS | sed 's/,/ --tag /g')" >> $GITHUB_OUTPUT

      - name: ğŸ³ Build and Push Docker Image
        run: |
          echo "Building with tags: --tag ${{ steps.tags.outputs.image_tags }}"

          docker build \
            --build-arg DB_PG_HOST=${{ env.DB_PG_HOST }} \
            --build-arg DB_PG_USER=${{ env.DB_PG_USER }} \
            --build-arg DB_PG_PASSWORD=${{ env.DB_PG_PASSWORD }} \
            --build-arg DB_PG_NAME=${{ secrets.DB_PG_NAME }} \
            --build-arg DB_PG_PORT=${{ secrets.DB_PG_PORT }} \
            --build-arg API_KEY=${{ secrets.API_KEY }} \
            --build-arg JWT_ACCESS_TOKEN_EXPIRATION_TIME=${{ secrets.JWT_ACCESS_TOKEN_EXPIRATION_TIME }} \
            --build-arg JWT_REFRESH_TOKEN_EXPIRATION_TIME=${{ secrets.JWT_REFRESH_TOKEN_EXPIRATION_TIME }} \
            --build-arg CUSTOMERS_GATEWAY_URL=${{ secrets.CUSTOMERS_GATEWAY_URL }} \
            --build-arg AUTHORIZER_KEY=${{ secrets.AUTHORIZER_KEY }} \
            --tag ${{ steps.tags.outputs.image_tags }} \
            --push .

      - name: Set outputs
        id: set-outputs
        run: |
          echo "terraform_bucket=$BUCKET_NAME" >> $GITHUB_OUTPUT

  deploy-to-eks:
    name: â˜ï¸ Deploy to EKS with Terraform
    runs-on: ubuntu-latest
    needs: build-and-push-image
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'

    steps:
      - name: ğŸ“¥ Checkout repo
        uses: actions/checkout@v4

      - name: ğŸ”‘ Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }}
          aws-region: us-east-1

      - name: Log the variables from terraform
        run: |
          echo ${{ needs.bootstrap.outputs.terraform_bucket }}

      - name: ğŸ” Verify AWS Identity
        run: |
          echo "ğŸ” Verifying AWS Identity..."
          aws sts get-caller-identity
          echo "âœ… AWS credentials are valid"

      - name: ğŸ“ Fetch DB Parameters from SSM
        id: ssm-params
        run: |
          PARAMS=$(aws ssm get-parameters --names "/main/rds_endpoint" "/main/db_username" "/main/db_password" --with-decryption --query "Parameters[].{Name:Name,Value:Value}" --output json)

          echo "DB_PG_HOST=$(echo $PARAMS | jq -r '.[] | select(.Name=="/main/rds_endpoint") | .Value')" >> $GITHUB_ENV
          echo "DB_PG_USER=$(echo $PARAMS | jq -r '.[] | select(.Name=="/main/db_username") | .Value')" >> $GITHUB_ENV
          DB_PASS=$(echo $PARAMS | jq -r '.[] | select(.Name=="/main/db_password") | .Value')
          echo "DB_PG_PASSWORD=$DB_PASS" >> $GITHUB_ENV

          echo "::add-mask::$DB_PASS"

      - name: ğŸ—ï¸ Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.6.0

      - name: âš™ï¸ Setup kubectl
        run: |
          curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
          chmod +x kubectl
          sudo mv kubectl /usr/local/bin/
          echo "ğŸ“ Updating kubeconfig for EKS cluster..."
          aws eks update-kubeconfig --region us-east-1 --name ${{ secrets.EKS_CLUSTER_NAME }}
          echo "âœ… Kubeconfig updated"

      - name: â˜ï¸ Verify EKS Access
        run: |
          echo "ğŸ” Testing EKS cluster access..."
          kubectl cluster-info
          kubectl get nodes
          echo "âœ… EKS cluster is accessible"

      - name: ğŸ”„ Terraform Init
        run: |
          cd terraform
          echo "ğŸ”§ Inicializando Terraform..."
          terraform init \
            -backend-config="bucket=${{ needs.build-and-push-image.outputs.terraform_bucket }}"
          echo "âœ… Terraform inicializado"

      - name: ğŸ“Š Log Terraform Variables
        env:
          TF_VAR_eks_cluster_name: ${{ secrets.EKS_CLUSTER_NAME }}
          TF_VAR_ecr_repository_url: ${{ secrets.ECR_REPOSITORY_URL }}
          TF_VAR_image_tag: ${{ github.sha }}
          TF_VAR_jwt_secret: ${{ secrets.JWT_SECRET }}
          TF_VAR_api_key: ${{ secrets.API_KEY }}
          TF_VAR_db_pg_name: ${{ secrets.DB_PG_NAME }}
          TF_VAR_db_pg_port: ${{ secrets.DB_PG_PORT }}
          TF_VAR_jwt_access_token_expiration_time: ${{ secrets.JWT_ACCESS_TOKEN_EXPIRATION_TIME }}
          TF_VAR_jwt_refresh_token_expiration_time: ${{ secrets.JWT_REFRESH_TOKEN_EXPIRATION_TIME }}
          TF_VAR_customers_gateway_url: ${{ secrets.CUSTOMERS_GATEWAY_URL }}
          TF_VAR_authorizer_key: ${{ secrets.AUTHORIZER_KEY }}
        run: |
          echo "ï¿½ Validando variÃ¡veis do Terraform..."
          echo ""
          echo "ğŸ“‹ VariÃ¡veis carregadas:"
          echo "  ğŸ—ï¸  EKS Cluster: ${TF_VAR_eks_cluster_name:-âŒ NÃƒO DEFINIDA}"
          echo "  ğŸ“¦ ECR Repository: ${TF_VAR_ecr_repository_url:-âŒ NÃƒO DEFINIDA}"
          echo "  ğŸ·ï¸  Image Tag: ${TF_VAR_image_tag:-âŒ NÃƒO DEFINIDA}"
          echo "  ï¿½ï¸  DB Name: ${TF_VAR_db_pg_name:-âŒ NÃƒO DEFINIDA}"
          echo "  ğŸ”Œ DB Port: ${TF_VAR_db_pg_port:-âŒ NÃƒO DEFINIDA}"
          echo "  â° JWT Access TTL: ${TF_VAR_jwt_access_token_expiration_time:-âŒ NÃƒO DEFINIDA}"
          echo "  ï¿½ JWT Refresh TTL: ${TF_VAR_jwt_refresh_token_expiration_time:-âŒ NÃƒO DEFINIDA}"
          echo ""
          echo "ï¿½ VariÃ¡veis sensÃ­veis (mascaradas):"
          echo "  ï¿½ JWT Secret: ${TF_VAR_jwt_secret:0:8}***[MASKED]"
          echo "  ğŸ—ï¸  API Key: ${TF_VAR_api_key:0:8}***[MASKED]"
          echo ""

          # Validar variÃ¡veis obrigatÃ³rias
          echo "âœ… Validando variÃ¡veis obrigatÃ³rias..."
          MISSING_VARS=""

          [[ -z "$TF_VAR_eks_cluster_name" ]] && MISSING_VARS="$MISSING_VARS EKS_CLUSTER_NAME"
          [[ -z "$TF_VAR_ecr_repository_url" ]] && MISSING_VARS="$MISSING_VARS ECR_REPOSITORY_URL"
          [[ -z "$TF_VAR_image_tag" ]] && MISSING_VARS="$MISSING_VARS IMAGE_TAG"
          [[ -z "$TF_VAR_jwt_secret" ]] && MISSING_VARS="$MISSING_VARS JWT_SECRET"
          [[ -z "$TF_VAR_api_key" ]] && MISSING_VARS="$MISSING_VARS API_KEY"
          [[ -z "$TF_VAR_db_pg_name" ]] && MISSING_VARS="$MISSING_VARS DB_PG_NAME"
          [[ -z "$TF_VAR_db_pg_port" ]] && MISSING_VARS="$MISSING_VARS DB_PG_PORT"
          [[ -z "$TF_VAR_jwt_access_token_expiration_time" ]] && MISSING_VARS="$MISSING_VARS JWT_ACCESS_TOKEN_EXPIRATION_TIME"
          [[ -z "$TF_VAR_jwt_refresh_token_expiration_time" ]] && MISSING_VARS="$MISSING_VARS JWT_REFRESH_TOKEN_EXPIRATION_TIME"
          [[ -z "$TF_VAR_customers_gateway_url" ]] && MISSING_VARS="$MISSING_VARS CUSTOMERS_GATEWAY_URL"
          [[ -z "$TF_VAR_authorizer_key" ]] && MISSING_VARS="$MISSING_VARS AUTHORIZER_KEY"


          if [[ -n "$MISSING_VARS" ]]; then
            echo "âŒ VariÃ¡veis faltando:$MISSING_VARS"
            echo "ğŸ’¡ Adicione essas variÃ¡veis nos GitHub Secrets"
            exit 1
          fi

          echo "âœ… Todas as variÃ¡veis obrigatÃ³rias estÃ£o definidas!"

      - name: ğŸ“ Terraform Plan
        env:
          TF_VAR_eks_cluster_name: ${{ secrets.EKS_CLUSTER_NAME }}
          TF_VAR_ecr_repository_url: ${{ secrets.ECR_REPOSITORY_URL }}
          TF_VAR_image_tag: ${{ github.sha }}
          TF_VAR_jwt_secret: ${{ secrets.JWT_SECRET }}
          TF_VAR_api_key: ${{ secrets.API_KEY }}
          TF_VAR_db_pg_name: ${{ secrets.DB_PG_NAME }}
          TF_VAR_db_pg_port: ${{ secrets.DB_PG_PORT }}
          TF_VAR_db_pg_host: ${{ env.DB_PG_HOST }}
          TF_VAR_db_pg_user: ${{ env.DB_PG_USER }}
          TF_VAR_db_pg_password: ${{ env.DB_PG_PASSWORD }}
          TF_VAR_jwt_access_token_expiration_time: ${{ secrets.JWT_ACCESS_TOKEN_EXPIRATION_TIME }}
          TF_VAR_jwt_refresh_token_expiration_time: ${{ secrets.JWT_REFRESH_TOKEN_EXPIRATION_TIME }}
          TF_VAR_customers_gateway_url: ${{ secrets.CUSTOMERS_GATEWAY_URL }}
          TF_VAR_authorizer_key: ${{ secrets.AUTHORIZER_KEY }}
        run: |
          cd terraform
          echo "ğŸ“‹ Planejando mudanÃ§as no Terraform..."
          terraform plan -no-color
          echo "âœ… Plano criado"
 
      - name: ğŸš€ Terraform Apply
        env:
          TF_VAR_eks_cluster_name: ${{ secrets.EKS_CLUSTER_NAME }}
          TF_VAR_ecr_repository_url: ${{ secrets.ECR_REPOSITORY_URL }}
          TF_VAR_image_tag: ${{ github.sha }}
          TF_VAR_jwt_secret: ${{ secrets.JWT_SECRET }}
          TF_VAR_api_key: ${{ secrets.API_KEY }}
          TF_VAR_db_pg_name: ${{ secrets.DB_PG_NAME }}
          TF_VAR_db_pg_port: ${{ secrets.DB_PG_PORT }}
          TF_VAR_db_pg_user: ${{ env.DB_PG_USER }}
          TF_VAR_db_pg_password: ${{ env.DB_PG_PASSWORD }}
          TF_VAR_db_pg_host: ${{ env.DB_PG_HOST }}
          TF_VAR_jwt_access_token_expiration_time: ${{ secrets.JWT_ACCESS_TOKEN_EXPIRATION_TIME }}
          TF_VAR_jwt_refresh_token_expiration_time: ${{ secrets.JWT_REFRESH_TOKEN_EXPIRATION_TIME }}
          TF_VAR_customers_gateway_url: ${{ secrets.CUSTOMERS_GATEWAY_URL }}
          TF_VAR_authorizer_key: ${{ secrets.AUTHORIZER_KEY }}
        run: |
          cd terraform
          echo "ğŸš€ Aplicando mudanÃ§as com Terraform..."
          terraform apply -auto-approve -no-color
          echo "âœ… Deploy realizado com sucesso!"

      - name: ğŸŒ Get Application URL
        run: |
          echo "ğŸŒ Aguardando URL da aplicaÃ§Ã£o..."
          echo "â³ LoadBalancer pode levar alguns minutos para ficar pronto..."

          for i in {1..30}; do
            EXTERNAL_IP=$(kubectl get svc tech-challenge-loadbalancer -n tech-challenge -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' 2>/dev/null || echo "")
            if [[ -n "$EXTERNAL_IP" ]]; then
              echo "âœ… LoadBalancer pronto!"
              echo "ğŸš€ URL da aplicaÃ§Ã£o: http://$EXTERNAL_IP"
              echo "ğŸ“‹ Para testar: curl http://$EXTERNAL_IP/health"
              break
            fi
            echo "â³ Aguardando... (tentativa $i/30)"
            sleep 10
          done

          if [[ -z "$EXTERNAL_IP" ]]; then
            echo "âš ï¸  LoadBalancer ainda configurando..."
            echo "ğŸ“ Execute: kubectl get svc tech-challenge-loadbalancer -n tech-challenge"
          fi

          echo "ğŸ“Š Status final dos recursos:"
          kubectl get all -n tech-challenge
