name: CI/CD Pipeline

on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main

jobs:
  test:
    name: üß™ Run Tests
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'

    steps:
      - name: üì• Checkout repo
        uses: actions/checkout@v4

      - name: üü¢ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "18"
          cache: "npm"

      - name: üì¶ Install dependencies
        run: npm ci

      - name: üé® Run linting
        run: npm run lint

      - name: üß™ Run tests
        run: npm test

      - name: üèóÔ∏è Build application
        run: npm run build

  build-and-push-image:
    name: üì¶ Build and Push to ECR
    runs-on: ubuntu-latest
    outputs:
      terraform_bucket: ${{ steps.set-outputs.outputs.terraform_bucket }}
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'

    steps:
      - name: üì• Checkout repo
        uses: actions/checkout@v4

      - name: üîë Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }}
          aws-region: us-east-1

      - name: ‚úÖ Verify AWS Identity
        run: aws sts get-caller-identity

      - name: Create S3 Bucket for Terraform State
        id: bootstrap
        run: |
          BUCKET_PREFIX="terraform-state"
          ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          echo "AWS Account ID: $ACCOUNT_ID"

          REGION="us-east-1"
          BUCKET_NAME="${BUCKET_PREFIX}-${ACCOUNT_ID}"
          echo "S3 bucket name: $BUCKET_NAME"

          # Check if bucket exists, create if not
          echo "Checking S3 bucket..."
          if aws s3api head-bucket --bucket "$BUCKET_NAME" 2>/dev/null; then
            echo "S3 bucket '$BUCKET_NAME' already exists"
          else
            echo "Creating S3 bucket '$BUCKET_NAME'..."
            aws s3api create-bucket --bucket "$BUCKET_NAME" --region "$REGION"
            echo "S3 bucket '$BUCKET_NAME' created successfully"
          fi

          echo "Bootstrap finished. Bucket: $BUCKET_NAME"
          echo "BUCKET_NAME=$BUCKET_NAME" >> $GITHUB_ENV

      - name: üìé Fetch DB Parameters from SSM
        id: ssm-params
        run: |
          PARAMS=$(aws ssm get-parameters --names "/main/rds_endpoint" "/main/db_username" "/main/db_password" --with-decryption --query "Parameters[].{Name:Name,Value:Value}" --output json)

          echo "DB_PG_HOST=$(echo $PARAMS | jq -r '.[] | select(.Name=="/main/rds_endpoint") | .Value')" >> $GITHUB_ENV
          echo "DB_PG_USER=$(echo $PARAMS | jq -r '.[] | select(.Name=="/main/db_username") | .Value')" >> $GITHUB_ENV
          DB_PASS=$(echo $PARAMS | jq -r '.[] | select(.Name=="/main/db_password") | .Value')
          echo "DB_PG_PASSWORD=$DB_PASS" >> $GITHUB_ENV

          echo "::add-mask::$DB_PASS"

      - name: üì¶ Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: üè∑Ô∏è Define Image Tags
        id: tags
        run: |
          COMMIT_HASH=${{ github.sha }}
          ECR_URL=${{ secrets.ECR_REPOSITORY_URL }} # Usa a URL do reposit√≥rio a partir dos segredos

          TAGS="${ECR_URL}:${COMMIT_HASH}"

          if [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            TAGS="$TAGS,${ECR_URL}:latest,${ECR_URL}:main"
          fi

          echo "image_tags=$(echo $TAGS | sed 's/,/ --tag /g')" >> $GITHUB_OUTPUT

      - name: üê≥ Build and Push Docker Image
        run: |
          echo "Building with tags: --tag ${{ steps.tags.outputs.image_tags }}"

          docker build \
            --build-arg DB_PG_HOST=${{ env.DB_PG_HOST }} \
            --build-arg DB_PG_USER=${{ env.DB_PG_USER }} \
            --build-arg DB_PG_PASSWORD=${{ env.DB_PG_PASSWORD }} \
            --build-arg DB_PG_NAME=${{ secrets.DB_PG_NAME }} \
            --build-arg DB_PG_PORT=${{ secrets.DB_PG_PORT }} \
            --build-arg API_KEY=${{ secrets.API_KEY }} \
            --build-arg JWT_ACCESS_TOKEN_EXPIRATION_TIME=${{ secrets.JWT_ACCESS_TOKEN_EXPIRATION_TIME }} \
            --build-arg JWT_REFRESH_TOKEN_EXPIRATION_TIME=${{ secrets.JWT_REFRESH_TOKEN_EXPIRATION_TIME }} \
            --build-arg CUSTOMERS_GATEWAY_URL=${{ secrets.CUSTOMERS_GATEWAY_URL }} \
            --build-arg AUTHORIZER_KEY=${{ secrets.AUTHORIZER_KEY }} \
            --tag ${{ steps.tags.outputs.image_tags }} \
            --push .

      - name: Set outputs
        id: set-outputs
        run: |
          echo "terraform_bucket=$BUCKET_NAME" >> $GITHUB_OUTPUT

  deploy-to-eks:
    name: ‚òÅÔ∏è Deploy to EKS with Terraform
    runs-on: ubuntu-latest
    needs: build-and-push-image
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'

    steps:
      - name: üì• Checkout repo
        uses: actions/checkout@v4

      - name: üîë Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }}
          aws-region: us-east-1

      - name: Log the variables from terraform
        run: |
          echo ${{ needs.bootstrap.outputs.terraform_bucket }}

      - name: üîç Verify AWS Identity
        run: |
          echo "üîç Verifying AWS Identity..."
          aws sts get-caller-identity
          echo "‚úÖ AWS credentials are valid"

      - name: üìé Fetch DB Parameters from SSM
        id: ssm-params
        run: |
          PARAMS=$(aws ssm get-parameters --names "/main/rds_endpoint" "/main/db_username" "/main/db_password" --with-decryption --query "Parameters[].{Name:Name,Value:Value}" --output json)

          echo "DB_PG_HOST=$(echo $PARAMS | jq -r '.[] | select(.Name=="/main/rds_endpoint") | .Value')" >> $GITHUB_ENV
          echo "DB_PG_USER=$(echo $PARAMS | jq -r '.[] | select(.Name=="/main/db_username") | .Value')" >> $GITHUB_ENV
          DB_PASS=$(echo $PARAMS | jq -r '.[] | select(.Name=="/main/db_password") | .Value')
          echo "DB_PG_PASSWORD=$DB_PASS" >> $GITHUB_ENV

          echo "::add-mask::$DB_PASS"

      - name: üèóÔ∏è Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.6.0

      - name: ‚öôÔ∏è Setup kubectl
        run: |
          curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
          chmod +x kubectl
          sudo mv kubectl /usr/local/bin/
          echo "üìù Updating kubeconfig for EKS cluster..."
          aws eks update-kubeconfig --region us-east-1 --name ${{ secrets.EKS_CLUSTER_NAME }}
          echo "‚úÖ Kubeconfig updated"

      - name: ‚òÅÔ∏è Verify EKS Access
        run: |
          echo "üîç Testing EKS cluster access..."
          kubectl cluster-info
          kubectl get nodes
          echo "‚úÖ EKS cluster is accessible"

      - name: üîÑ Terraform Init
        run: |
          cd terraform
          echo "üîß Inicializando Terraform..."
          terraform init \
            -backend-config="bucket=${{ needs.build-and-push-image.outputs.terraform_bucket }}"
          echo "‚úÖ Terraform inicializado"

      - name: üìä Log Terraform Variables
        env:
          TF_VAR_eks_cluster_name: ${{ secrets.EKS_CLUSTER_NAME }}
          TF_VAR_ecr_repository_url: ${{ secrets.ECR_REPOSITORY_URL }}
          TF_VAR_image_tag: ${{ github.sha }}
          TF_VAR_jwt_secret: ${{ secrets.JWT_SECRET }}
          TF_VAR_api_key: ${{ secrets.API_KEY }}
          TF_VAR_db_pg_name: ${{ secrets.DB_PG_NAME }}
          TF_VAR_db_pg_port: ${{ secrets.DB_PG_PORT }}
          TF_VAR_jwt_access_token_expiration_time: ${{ secrets.JWT_ACCESS_TOKEN_EXPIRATION_TIME }}
          TF_VAR_jwt_refresh_token_expiration_time: ${{ secrets.JWT_REFRESH_TOKEN_EXPIRATION_TIME }}
          TF_VAR_customers_gateway_url: ${{ secrets.CUSTOMERS_GATEWAY_URL }}
          TF_VAR_authorizer_key: ${{ secrets.AUTHORIZER_KEY }}
        run: |
          echo "ÔøΩ Validando vari√°veis do Terraform..."
          echo ""
          echo "üìã Vari√°veis carregadas:"
          echo "  üèóÔ∏è  EKS Cluster: ${TF_VAR_eks_cluster_name:-‚ùå N√ÉO DEFINIDA}"
          echo "  üì¶ ECR Repository: ${TF_VAR_ecr_repository_url:-‚ùå N√ÉO DEFINIDA}"
          echo "  üè∑Ô∏è  Image Tag: ${TF_VAR_image_tag:-‚ùå N√ÉO DEFINIDA}"
          echo "  ÔøΩÔ∏è  DB Name: ${TF_VAR_db_pg_name:-‚ùå N√ÉO DEFINIDA}"
          echo "  üîå DB Port: ${TF_VAR_db_pg_port:-‚ùå N√ÉO DEFINIDA}"
          echo "  ‚è∞ JWT Access TTL: ${TF_VAR_jwt_access_token_expiration_time:-‚ùå N√ÉO DEFINIDA}"
          echo "  ÔøΩ JWT Refresh TTL: ${TF_VAR_jwt_refresh_token_expiration_time:-‚ùå N√ÉO DEFINIDA}"
          echo ""
          echo "ÔøΩ Vari√°veis sens√≠veis (mascaradas):"
          echo "  ÔøΩ JWT Secret: ${TF_VAR_jwt_secret:0:8}***[MASKED]"
          echo "  üóùÔ∏è  API Key: ${TF_VAR_api_key:0:8}***[MASKED]"
          echo ""

          # Validar vari√°veis obrigat√≥rias
          echo "‚úÖ Validando vari√°veis obrigat√≥rias..."
          MISSING_VARS=""

          [[ -z "$TF_VAR_eks_cluster_name" ]] && MISSING_VARS="$MISSING_VARS EKS_CLUSTER_NAME"
          [[ -z "$TF_VAR_ecr_repository_url" ]] && MISSING_VARS="$MISSING_VARS ECR_REPOSITORY_URL"
          [[ -z "$TF_VAR_image_tag" ]] && MISSING_VARS="$MISSING_VARS IMAGE_TAG"
          [[ -z "$TF_VAR_jwt_secret" ]] && MISSING_VARS="$MISSING_VARS JWT_SECRET"
          [[ -z "$TF_VAR_api_key" ]] && MISSING_VARS="$MISSING_VARS API_KEY"
          [[ -z "$TF_VAR_db_pg_name" ]] && MISSING_VARS="$MISSING_VARS DB_PG_NAME"
          [[ -z "$TF_VAR_db_pg_port" ]] && MISSING_VARS="$MISSING_VARS DB_PG_PORT"
          [[ -z "$TF_VAR_jwt_access_token_expiration_time" ]] && MISSING_VARS="$MISSING_VARS JWT_ACCESS_TOKEN_EXPIRATION_TIME"
          [[ -z "$TF_VAR_jwt_refresh_token_expiration_time" ]] && MISSING_VARS="$MISSING_VARS JWT_REFRESH_TOKEN_EXPIRATION_TIME"
          [[ -z "$TF_VAR_customers_gateway_url" ]] && MISSING_VARS="$MISSING_VARS CUSTOMERS_GATEWAY_URL"
          [[ -z "$TF_VAR_authorizer_key" ]] && MISSING_VARS="$MISSING_VARS AUTHORIZER_KEY"


          if [[ -n "$MISSING_VARS" ]]; then
            echo "‚ùå Vari√°veis faltando:$MISSING_VARS"
            echo "üí° Adicione essas vari√°veis nos GitHub Secrets"
            exit 1
          fi

          echo "‚úÖ Todas as vari√°veis obrigat√≥rias est√£o definidas!"

      - name: üìù Terraform Plan
        env:
          TF_VAR_eks_cluster_name: ${{ secrets.EKS_CLUSTER_NAME }}
          TF_VAR_ecr_repository_url: ${{ secrets.ECR_REPOSITORY_URL }}
          TF_VAR_image_tag: ${{ github.sha }}
          TF_VAR_jwt_secret: ${{ secrets.JWT_SECRET }}
          TF_VAR_api_key: ${{ secrets.API_KEY }}
          TF_VAR_db_pg_name: ${{ secrets.DB_PG_NAME }}
          TF_VAR_db_pg_port: ${{ secrets.DB_PG_PORT }}
          TF_VAR_db_pg_host: ${{ env.DB_PG_HOST }}
          TF_VAR_db_pg_user: ${{ env.DB_PG_USER }}
          TF_VAR_db_pg_password: ${{ env.DB_PG_PASSWORD }}
          TF_VAR_jwt_access_token_expiration_time: ${{ secrets.JWT_ACCESS_TOKEN_EXPIRATION_TIME }}
          TF_VAR_jwt_refresh_token_expiration_time: ${{ secrets.JWT_REFRESH_TOKEN_EXPIRATION_TIME }}
          TF_VAR_customers_gateway_url: ${{ secrets.CUSTOMERS_GATEWAY_URL }}
          TF_VAR_authorizer_key: ${{ secrets.AUTHORIZER_KEY }}
        run: |
          cd terraform
          echo "üìã Planejando mudan√ßas no Terraform..."
          terraform plan -no-color
          echo "‚úÖ Plano criado"
 
      - name: üöÄ Terraform Apply
        env:
          TF_VAR_eks_cluster_name: ${{ secrets.EKS_CLUSTER_NAME }}
          TF_VAR_ecr_repository_url: ${{ secrets.ECR_REPOSITORY_URL }}
          TF_VAR_image_tag: ${{ github.sha }}
          TF_VAR_jwt_secret: ${{ secrets.JWT_SECRET }}
          TF_VAR_api_key: ${{ secrets.API_KEY }}
          TF_VAR_db_pg_name: ${{ secrets.DB_PG_NAME }}
          TF_VAR_db_pg_port: ${{ secrets.DB_PG_PORT }}
          TF_VAR_db_pg_user: ${{ env.DB_PG_USER }}
          TF_VAR_db_pg_password: ${{ env.DB_PG_PASSWORD }}
          TF_VAR_db_pg_host: ${{ env.DB_PG_HOST }}
          TF_VAR_jwt_access_token_expiration_time: ${{ secrets.JWT_ACCESS_TOKEN_EXPIRATION_TIME }}
          TF_VAR_jwt_refresh_token_expiration_time: ${{ secrets.JWT_REFRESH_TOKEN_EXPIRATION_TIME }}
          TF_VAR_customers_gateway_url: ${{ secrets.CUSTOMERS_GATEWAY_URL }}
          TF_VAR_authorizer_key: ${{ secrets.AUTHORIZER_KEY }}
        run: |
          cd terraform
          echo "üöÄ Aplicando mudan√ßas com Terraform..."
          terraform apply -auto-approve -no-color
          echo "‚úÖ Deploy realizado com sucesso!"

      - name: üåê Get Application URL
        run: |
          echo "üåê Aguardando URL da aplica√ß√£o..."
          echo "‚è≥ LoadBalancer pode levar alguns minutos para ficar pronto..."

          for i in {1..30}; do
            EXTERNAL_IP=$(kubectl get svc tech-challenge-loadbalancer -n tech-challenge -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' 2>/dev/null || echo "")
            if [[ -n "$EXTERNAL_IP" ]]; then
              echo "‚úÖ LoadBalancer pronto!"
              echo "üöÄ URL da aplica√ß√£o: http://$EXTERNAL_IP"
              echo "üìã Para testar: curl http://$EXTERNAL_IP/health"
              break
            fi
            echo "‚è≥ Aguardando... (tentativa $i/30)"
            sleep 10
          done

          if [[ -z "$EXTERNAL_IP" ]]; then
            echo "‚ö†Ô∏è  LoadBalancer ainda configurando..."
            echo "üìù Execute: kubectl get svc tech-challenge-loadbalancer -n tech-challenge"
          fi

          echo "üìä Status final dos recursos:"
          kubectl get all -n tech-challenge
