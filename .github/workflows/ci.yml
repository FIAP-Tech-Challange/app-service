name: Build and Push to ECR

on:
  push:
    branches:
      - main

jobs:
  build-and-push-image:
    name: Build and Push to ECR
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }}
          aws-region: us-east-1

      - name: Verify AWS Identity
        run: aws sts get-caller-identity

      - name: Fetch DB Parameters from SSM
        id: ssm-params
        run: |
          PARAMS=$(aws ssm get-parameters --names "/main/rds_endpoint" "main/db_username" "main/db_password" --with-decryption --query "Parameters[].{Name:Name,Value:Value}" --output json)
          
          echo "DB_PG_HOST=$(echo $PARAMS | jq -r '.[] | select(.Name=="/main/rds_endpoint") | .Value')" >> $GITHUB_ENV
          echo "DB_PG_USER=$(echo $PARAMS | jq -r '.[] | select(.Name=="main/db_username") | .Value')" >> $GITHUB_ENV
          DB_PASS=$(echo $PARAMS | jq -r '.[] | select(.Name=="main/db_password") | .Value')
          echo "DB_PG_PASSWORD=$DB_PASS" >> $GITHUB_ENV
          
          echo "::add-mask::$DB_PASS"

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Define Image Tags
        id: tags
        run: |
          COMMIT_HASH=$(echo ${{ github.sha }} | cut -c1-7)
          ECR_URL=${{ secrets.ECR_REPOSITORY_URL }} # Usa a URL do reposit√≥rio a partir dos segredos
          
          TAGS="${ECR_URL}:${COMMIT_HASH}"
          
          if [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            TAGS="$TAGS,${ECR_URL}:latest,${ECR_URL}:main"
          fi
          
          echo "image_tags=$(echo $TAGS | sed 's/,/ --tag /g')" >> $GITHUB_OUTPUT
        
      - name: Build and Push Docker Image
        run: |
          echo "Building with tags: --tag ${{ steps.tags.outputs.image_tags }}"
          
          docker build \
            --build-arg DB_PG_HOST=${{ env.DB_PG_HOST }} \
            --build-arg DB_PG_USER=${{ env.DB_PG_USER }} \
            --build-arg DB_PG_PASSWORD=${{ env.DB_PG_PASSWORD }} \
            --build-arg DB_PG_NAME=${{ secrets.DB_PG_NAME }} \
            --build-arg DB_PG_PORT=${{ secrets.DB_PG_PORT }} \
            --build-arg API_KEY=${{ secrets.API_KEY }} \
            --build-arg JWT_ACCESS_TOKEN_EXPIRATION_TIME=${{ secrets.JWT_ACCESS_TOKEN_EXPIRATION_TIME }} \
            --build-arg JWT_REFRESH_TOKEN_EXPIRATION_TIME=${{ secrets.JWT_REFRESH_TOKEN_EXPIRATION_TIME }} \
            --tag ${{ steps.tags.outputs.image_tags }} \
            --push .

  deploy-to-eks:
    name: Deploy to EKS
    runs-on: ubuntu-latest
    needs: build-and-push-image
    if: github.ref == 'refs/heads/main'

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }}
          aws-region: us-east-1

      - name: Fetch DB Parameters from SSM
        id: ssm-params-deploy
        run: |
          echo "üîç Buscando par√¢metros do banco no SSM para deploy..."
          echo "üìã Par√¢metros solicitados:"
          echo "  ‚Ä¢ /main/rds_endpoint"
          echo "  ‚Ä¢ main/db_username"
          echo "  ‚Ä¢ main/db_password"
          
          PARAMS=$(aws ssm get-parameters --names "/main/rds_endpoint" "main/db_username" "main/db_password" --with-decryption --query "Parameters[].{Name:Name,Value:Value}" --output json)
          
          # Extrair valores
          DB_HOST=$(echo $PARAMS | jq -r '.[] | select(.Name=="/main/rds_endpoint") | .Value')
          DB_USER=$(echo $PARAMS | jq -r '.[] | select(.Name=="main/db_username") | .Value')
          DB_PASS=$(echo $PARAMS | jq -r '.[] | select(.Name=="main/db_password") | .Value')
          
          # Definir vari√°veis de ambiente
          echo "DB_PG_HOST=$DB_HOST" >> $GITHUB_ENV
          echo "DB_PG_USER=$DB_USER" >> $GITHUB_ENV
          echo "DB_PG_PASSWORD=$DB_PASS" >> $GITHUB_ENV
          
          echo "::add-mask::$DB_PASS"
          
          echo "‚úÖ Par√¢metros obtidos do SSM:"
          echo "  üèõÔ∏è  DB Host: $DB_HOST"
          echo "  üë§ DB User: $DB_USER"
          echo "  üîê DB Password: ${DB_PASS:0:3}***[MASKED]"

      - name: Setup Kubernetes Tools
        run: |
          # Install kubectl
          curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
          chmod +x kubectl
          sudo mv kubectl /usr/local/bin/
          
          # Install kustomize
          curl -s "https://raw.githubusercontent.com/kubernetes-sigs/kustomize/master/hack/install_kustomize.sh" | bash
          sudo mv kustomize /usr/local/bin/
          
          # Configure kubectl
          aws eks update-kubeconfig --region us-east-1 --name ${{ secrets.EKS_CLUSTER_NAME }}

      - name: Deploy Application
        env:
          ECR_REPOSITORY_URL: ${{ secrets.ECR_REPOSITORY_URL }}
          DB_PG_HOST: ${{ env.DB_PG_HOST }}
          DB_PG_USER: ${{ env.DB_PG_USER }}
          DB_PG_PASSWORD: ${{ env.DB_PG_PASSWORD }}
          DB_PG_NAME: ${{ secrets.DB_PG_NAME }}
          DB_PG_PORT: ${{ secrets.DB_PG_PORT }}
          API_KEY: ${{ secrets.API_KEY }}
          JWT_SECRET: ${{ secrets.JWT_SECRET }}
          JWT_ACCESS_TOKEN_EXPIRATION_TIME: ${{ secrets.JWT_ACCESS_TOKEN_EXPIRATION_TIME }}
          JWT_REFRESH_TOKEN_EXPIRATION_TIME: ${{ secrets.JWT_REFRESH_TOKEN_EXPIRATION_TIME }}
        run: |
          cd k8s
          
          echo "üöÄ Iniciando deploy da aplica√ß√£o..."

          echo "üìã Vari√°veis de configura√ß√£o:"
          echo "  üèóÔ∏è  ECR Repository: $ECR_REPOSITORY_URL"
          echo "  üèõÔ∏è  Database Host: $DB_PG_HOST"
          echo "  üë§ Database User: $DB_PG_USER"
          echo "  ÔøΩ Database Password: ${DB_PG_PASSWORD:0:3}***[MASKED]"
          echo "  ÔøΩüóÉÔ∏è  Database Name: $DB_PG_NAME"
          echo "  üîå Database Port: $DB_PG_PORT"
          echo "  üîë API Key: ${API_KEY:0:8}***[MASKED]"
          echo "  üîê JWT Secret: ${JWT_SECRET:0:5}***[MASKED]"
          echo "  ‚è∞ JWT Access Token TTL: $JWT_ACCESS_TOKEN_EXPIRATION_TIME"
          echo "  üîÑ JWT Refresh Token TTL: $JWT_REFRESH_TOKEN_EXPIRATION_TIME"
          echo ""
          
          # Validar vari√°veis obrigat√≥rias
          echo "üîç Validando vari√°veis obrigat√≥rias..."
          if [[ -z "$ECR_REPOSITORY_URL" ]]; then
            echo "‚ùå Erro: ECR_REPOSITORY_URL n√£o definida"
            exit 1
          fi
          if [[ -z "$DB_PG_HOST" ]]; then
            echo "‚ùå Erro: DB_PG_HOST n√£o definida"
            exit 1
          fi
          if [[ -z "$DB_PG_USER" ]]; then
            echo "‚ùå Erro: DB_PG_USER n√£o definida"
            exit 1
          fi
          if [[ -z "$DB_PG_PASSWORD" ]]; then
            echo "‚ùå Erro: DB_PG_PASSWORD n√£o definida"
            exit 1
          fi
          echo "‚úÖ Todas as vari√°veis obrigat√≥rias validadas"
          
          # Configurar imagem dinamicamente
          echo "üîÑ Configurando imagem do ECR..."
          kustomize edit set image tech-challenge=$ECR_REPOSITORY_URL:latest
          echo "‚úÖ Imagem configurada: $ECR_REPOSITORY_URL:latest"
          
          # Criar secrets dinamicamente
          echo "üîê Criando secrets..."
          kubectl create secret generic tech-challenge-secrets \
            --from-literal=DB_PG_HOST="$DB_PG_HOST" \
            --from-literal=DB_PG_USER="$DB_PG_USER" \
            --from-literal=DB_PG_PASSWORD="$DB_PG_PASSWORD" \
            --from-literal=DB_PG_NAME="$DB_PG_NAME" \
            --from-literal=DB_PG_PORT="$DB_PG_PORT" \
            --from-literal=API_KEY="$API_KEY" \
            --from-literal=JWT_SECRET="$JWT_SECRET" \
            --from-literal=JWT_ACCESS_TOKEN_EXPIRATION_TIME="$JWT_ACCESS_TOKEN_EXPIRATION_TIME" \
            --from-literal=JWT_REFRESH_TOKEN_EXPIRATION_TIME="$JWT_REFRESH_TOKEN_EXPIRATION_TIME" \
            --namespace=tech-challenge \
            --dry-run=client -o yaml | kubectl apply -f -
          echo "‚úÖ Secrets criados"
          
          # Deploy usando kustomize
          echo "üì¶ Aplicando manifests..."
          kustomize build . | kubectl apply -f -
          echo "‚úÖ Manifests aplicados"
          
          # Aguardar rollout
          echo "‚è≥ Aguardando deployment..."
          kubectl rollout status deployment/tech-challenge-app -n tech-challenge --timeout=300s
          
          echo "üéâ Deploy conclu√≠do com sucesso!"
          echo "üìä Status dos pods:"
          kubectl get pods -n tech-challenge -l app=tech-challenge
          
          echo ""
          echo "üåê Aguardando URL da aplica√ß√£o..."
          echo "‚è≥ Esperando LoadBalancer obter IP externo (pode levar alguns minutos)..."
          
          # Aguardar LoadBalancer obter IP externo
          for i in {1..30}; do
            EXTERNAL_IP=$(kubectl get svc tech-challenge-loadbalancer -n tech-challenge -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' 2>/dev/null || echo "")
            if [[ -n "$EXTERNAL_IP" ]]; then
              echo "‚úÖ LoadBalancer pronto!"
              echo "üöÄ URL da aplica√ß√£o: http://$EXTERNAL_IP"
              echo "üìã Para testar: curl http://$EXTERNAL_IP/health"
              break
            fi
            echo "‚è≥ Aguardando... (tentativa $i/30)"
            sleep 10
          done
          
          if [[ -z "$EXTERNAL_IP" ]]; then
            echo "‚ö†Ô∏è  LoadBalancer ainda n√£o possui IP externo"
            echo "üìù Execute este comando para verificar:"
            echo "   kubectl get svc tech-challenge-loadbalancer -n tech-challenge"
          fi